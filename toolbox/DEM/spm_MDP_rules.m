function [pa,ru,mi] = spm_MDP_rules(label,pg)
% returns (likelihood) hypothesis or model space
% FORMAT [pa,ru,mi] = spm_MDP_rules(label,g)
%
% label  - annotated model
% pg     - modlity in question
%
% pa{:}  - {Dirichlet likelihood) model space
% ru{:}  - rules as text strings
% mi(:)  - mutual information
%
% This routine automatically creates a set of models, for a specified
% modality, given the annotation of latent states and outcome modalities.
% It first determines the size of the state space and likelihood mapping.
% It then identifies potential isomorphisms by identifying control factors
% that share more than one annotated state with noncontrollable factors,
% which become candidate criterion factors. It then identifies candidate
% context factors, whose levels uniquely specify the criterion factors.
% Finally, for every combination of context and criterion factors, a
% likelihood mapping is generated by assigning a Dirichlet account to a
% correct outcome, whenever the outcome matches the criterion state
% specified by the context state.
%__________________________________________________________________________

% Karl Friston
% Copyright (C) 2012-2022 Wellcome Centre for Human Neuroimaging


% get sizes of tensors
%==========================================================================
Nf = numel(label.factor);
Ng = numel(label.modality);
Ns = zeros(1,Nf);
for f = 1:Nf
    Ns(f) = numel(label.name{f});
    Nu(f) = numel(label.action{f});
end
No = zeros(1,Ng);
for g = 1:Ng
    No(g) = numel(label.outcome{g});
end

% shared levels (potential isomorphisms)
%--------------------------------------------------------------------------
for i = 1:Nf
    for j = 1:Nf
       U(i,j) = sum(ismember(label.name{i},label.name{j})) > 1;
    end
end

% levels of choice and criteria factors
%--------------------------------------------------------------------------
U(Nu == 1,:) = 0;
U(:,Nu >  1) = 0;
choice   = any(U');
criteria = any(U );

% indices of context factors
%--------------------------------------------------------------------------
Nc    = sum(criteria);             % number of criterion factors
Nr{1} = find((Ns == Nc));
for i = 1:Nc
    Nr{i + 1} = find(criteria);
end

% housekeeping indices
%--------------------------------------------------------------------------
null    = ~ismember(label.name{choice},label.name{find(criteria,1)});
null    =  find(null);
correct =  ismember(label.outcome{pg},{'right','correct',  'true', 'win'});
wrong   =  ismember(label.outcome{pg},{'wrong','incorrect','false','lose'});
other   = ~correct & ~wrong;


% preliminaries
%--------------------------------------------------------------------------
S     = spm_combinations(Ns);
R     = spm_combinations(Nr);
pa    = cell(1,size(R,1));
for j = 1:size(R,1)

    % for this rule
    %----------------------------------------------------------------------
    a     = zeros([No(pg),Ns]);
    for i = 1:size(S,1)

        % i-th combinations of latent states
        %------------------------------------------------------------------
        si = num2cell(S(i,:));

        % A{3} feedback: {'null','right','wrong'}
        %------------------------------------------------------------------
        if S(i,choice) == null

            % no choice
            %--------------------------------------------------------------
            a(other,si{:}) = 1;       % neither right nr wrong

        else

            % choice
            %--------------------------------------------------------------
            context        = R(j,1);
            criterion      = R(j,S(i,context) + 1);
            if S(i,choice) == S(i,criterion)
                a(correct,si{:}) = 1; % right
            else
                a(wrong,si{:})   = 1; % wrong
            end

        end
    end

    % likelihood model
    %----------------------------------------------------------------------
    pa{j} = spm_dir_norm(a);

    % string, if requested
    %----------------------------------------------------------------------
    if nargout > 1
        rule = {};
        for i = 1:Nc
            str = {'if ' label.factor{R(j,1)} ' is ' label.name{R(j,1)}{i} ...
                   ' then the ' label.factor{R(j,i + 1)} ' state is the correct ' ...
                   label.factor{choice} ': '};
            rule = [rule(:)' str(:)'];
        end
        ru{j} = cell2mat(rule);
    end

    % mutual information, if requested
    %----------------------------------------------------------------------
    if nargout > 2
        mi(j) = spm_MDP_MI(a);
    end

end

return
