function MDP = spm_daisy_chain(R,S,MDP,GDP)
% Selctive structure learning of a hierarchical POMDP
% FORMAT MDP = spm_daisy_chain(R,S,MDP,GDP)
% R    - cell array of outcomes
% S    - cell array (attracting set) of output sequences
% MDP  - cell array of (renormalising) models
%
% MDP  - new MDP
% O    - cell array of new paths in MDP
%
% This routine uses fast structure learning to append new trajectories to a
% recursive or renormalising generative model specified as a cell array of
% Markov decision processes. It augments past (generalised) states and
% transitions with new states and transitions given new outcomes (R), under
% the constraint that each event ends on the attracting set (S)
%
% See: spm_fast_structure_learning.m
%      spm_faster_structure_learning.m
%__________________________________________________________________________
% Copyright (C) 2005 Wellcome Trust Centre for Neuroimaging

% Karl Friston
% $Id: spm_MDP_structure_learning.m 8454 2023-11-04 17:09:11Z karl $
%__________________________________________________________________________


% preliminaries
%==========================================================================

% concatenation (probability coarse graining) and cost operators
%--------------------------------------------------------------------------
spm_discretise = @(O) logical(spm_cat([O(:,1:end - 1); O(:,2:end)]))';

% get outcomes generated by first factor [stream] at the highest level
%--------------------------------------------------------------------------
Nm    = numel(MDP);
Ne    = 2^(Nm - 1);
Ns    = size(MDP{Nm}.b{1},1);
g     = spm_get_outcomes(MDP,Nm,1:Ns);

% initial conditions of attracting paths
%--------------------------------------------------------------------------
U     = [];
for m = 1:numel(S)
    U(m,:) = spm_discretise(S{m}(g,1:2));
end
V     = spm_discretise(R(g,:));

% get costly paths
%--------------------------------------------------------------------------
if nargin > 3
    O     = spm_cat(R(GDP.id.contraint,:));
    [~,j] = max(O);
    c     = find(j > 1);
else
    c = 0;
end

% for each path in attracting set
%--------------------------------------------------------------------------
for m = find(ismember(U,V,'rows')')

    % find paths in R that end on attracting set
    %----------------------------------------------------------------------
    r     = find(ismember(V,U(m,:),'rows')');
    for i = 1:numel(r)

        % and append new path ([R(:,t),S{m}])
        %------------------------------------------------------------------
        t = (r(i) - Ne):(r(i) - 1);
        if numel(t) >= Ne && ~any(ismember(t,c)) && all(t > 0)
            MDP = spm_merge_structure_learning([R(:,t),S{m}],MDP);
        end
    end
end

% remove C (and U) in case the sizes of states have changed
%==========================================================================
for n = 1:Nm
    if isfield(MDP{n},'U')
        MDP{n} = rmfield(MDP{n},'U');
    end
    if isfield(MDP{n},'C')
        MDP{n} = rmfield(MDP{n},'C');
    end
end

return



